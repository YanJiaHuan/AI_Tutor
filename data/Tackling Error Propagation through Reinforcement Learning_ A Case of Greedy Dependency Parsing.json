{
    "Abstract": "Abstract Error propagation is a common problem in NLP. Reinforcement learning explores erroneous states during training and can therefore be more robust when mistakes are made early in a process. In this paper, we apply reinforcement learning to greedy dependency parsing which is known to suffer from error propagation. Reinforcement learning improves accuracy of both labeled and unlabeled dependencies of the Stanford Neural Dependency Parser, a high performance greedy parser, while maintaining its ef\ufb01ciency. We investigate the portion of errors which are the result of error propagation and con\ufb01rm that reinforcement learning reduces the occurrence of error propagation. 1 ",
    "Introduction": "Introduction Error propagation is a common problem for many NLP tasks (Song et al., 2012; Quirk and CorstonOliver, 2006; Han et al., 2013; Gildea and Palmer, 2002; Yang and Cardie, 2013). It can occur when NLP tools applied early on in a pipeline make mistakes that have negative impact on higher-level tasks further down the pipeline. It can also occur within the application of a speci\ufb01c task, when sequential decisions are taken and errors made early in the process affect decisions made later on. When reinforcement learning is applied, a system actively tries out different sequences of actions. Most of these sequences will contain some errors. We hypothesize that a system trained in this manner will be more robust and less susceptible to error propagation. We test our hypothesis by applying reinforcement learning to greedy transition-based parsers (Yamada and Matsumoto, 2003; Nivre, 2004), which have been popular because of superior ef\ufb01ciency and accuracy nearing state-of-the-art. They are also known to suffer from error propagation. Because they work by carrying out a sequence of actions without reconsideration, an erroneous action can exert a negative effect on all subsequent decisions. By rendering correct parses unreachable or promoting incorrect features, the \ufb01rst error induces the second error and so on. McDonald and Nivre (2007) argue that the observed negative correlation between parsing accuracy and sentence length indicates error propagation is at work. We compare reinforcement learning to supervised learning on Chen and Manning (2014)\u2019s parser. This high performance parser is available as open source. It does not make use of alternative strategies for tackling error propagation and thus provides a clean experimental setup to test our hypothesis. Reinforcement learning increased both unlabeled and labeled accuracy on the Penn TreeBank and German part of SPMRL (Seddah et al., 2014). This outcome shows that reinforcement learning has a positive effect, but does not yet prove that this is indeed the result of reduced error propagation. We therefore designed an experiment which identi\ufb01ed which errors are the result of error propagation. We found that around 50% of avoided errors were cases of error propagation in our best arc-standard system. Considering that 27% of the original errors were caused by error propagation, this result con\ufb01rms our hypothesis. This paper provides the following contributions: 1. We introduce Approximate Policy Gradient (APG), a new algorithm that is suited for dependency parsing and other structured prediction problems. 2. We show that this algorithm improves the accuracy of a high-performance greedy parser. arXiv:1702.06794v1  [cs.CL]  22 Feb 2017 ",
    "Related Work": "Related Work In this section, we address related work on dependency parsing, including alternative approaches for reducing error propagation, and reinforcement learning. 2.1 Dependency Parsing We use Chen and Manning (2014)\u2019s parser as a basis for our experiments. Their parser is opensource and has served as a reference point for many recent publications (Dyer et al., 2015; Weiss et al., 2015; Alberti et al., 2015; Honnibal and Johnson, 2015, among others). They provide an ef\ufb01cient neural network that learns dense vector representations of words, PoS-tags and dependency labels. This small set of features makes their parser signi\ufb01cantly more ef\ufb01cient than other popular parsers, such as the Malt (Nivre et al., 2007) or MST (McDonald et al., 2005) parser while obtaining higher accuracy. They acknowledge the error propagation problem of greedy parsers, but leave addressing this through (e.g.) beam search for future work. Dyer et al. (2015) introduce an approach that uses Long Short-Term Memory (LSTM). Their parser still works incrementally and the number of required operations grows linearly with the length of the sentence, but it uses the complete buffer, stack and history of parsing decisions, giving the model access to global information. Weiss et al. (2015) introduce several improvements on Chen and Manning (2014)\u2019s parser. Most importantly, they put a globally-trained perceptron layer instead of a softmax output layer. Their model uses smaller embeddings, recti\ufb01ed linear instead of cubic activation function, and two hidden layers instead of one. They furthermore apply an averaged stochastic gradient descent (ASGD) learning scheme. In addition, they apply beam search and increase training data by using unlabeled data through the tri-training approach introduced by Li et al. (2014), which leads to further improvements. Kiperwasser and Goldberg (2016) introduce a new way to represent features using a bidirectional LSTM and improve the results of a greedy parser. Andor et al. (2016) present a mathematical proof that globally normalized models are more expressive than locally normalized counterparts and propose to use global normalization with beam search at both training and testing. Our approach differs from all of the work mentioned above, in that it manages to improve results of Chen and Manning (2014) without changing the architecture of the model nor the input representation. The only substantial difference lies in the way the model is trained. In this respect, our research is most similar to training approaches using dynamic oracles (Goldberg and Nivre, 2012). Traditional static oracles can generate only one sequence of actions per sentence. A dynamic oracle gives all trajectories leading to the best possible result from every valid parse con\ufb01guration. They can therefore be used to generate more training sequences including those containing errors. A drawback of this approach is that dynamic oracles have to be developed speci\ufb01cally for individual transition systems (e.g. arc-standard, arceager). Therefore, a large number of dynamic oracles have been developed in recent years (Goldberg and Nivre, 2012; Goldberg and Nivre, 2013; Goldberg et al., 2014; Gomez-Rodriguez et al., 2014; Bj\u00f6rkelund and Nivre, 2015). In contrast, the reinforcement learning approach proposed in this paper is more general and can be applied to a variety of systems. Zhang and Chan (2009) present the only study we are aware of that also uses reinforcement learning for dependency parsing. They compare their results to Nivre et al. (2006b) using the same features, but they also change the model and apply beam search. It is thus unclear to what extend their improvements are due to reinforcement learning. Even though most approaches mentioned above improve the results reported by Chen and Manning (2014) and even more impressive results on dependency parsing have been achieved since (notably, Andor et al. (2016)), Chen and Manning\u2019s parser provides a better baseline for our purposes. We aim at investigating the in\ufb02uence of reinforcement learning on error propagation and want to test this in a clean environment, where reinforcement learning does not interfere with other methods that address the same problem. 2.2 Reinforcement Learning Reinforcement learning has been applied to several NLP tasks with success, e.g. agenda-based parsing (Jiang et al., 2012), semantic parsing (Berant and Liang, 2015) and simultaneous machine translation (Grissom II et al., 2014). To our knowledge, however, none of these studies investigated the in\ufb02uence of reinforcement learning on error propagation. Learning to Search (L2S) is probably the most prominent line of research that applies reinforcement learning (more precisely, imitation learning) to NLP. Various algorithms, e.g. SEARN (Daum\u00e9 III et al., 2009) and DAgger (Ross et al., 2011), have been developed sharing common high-level steps: a roll-in policy is executed to generate training states from which a roll-out policy is used to estimate the loss of certain actions. The concrete instantiation differs from one algorithm to another with choices including a referent policy (static or dynamic oracle), learned policy, or a mixture of the two. Early work in L2S focused on reducing reinforcement learning into binary classi\ufb01cation (Daum\u00e9 III et al., 2009), but newer systems favored regressors for ef\ufb01ciency (Chang et al., 2015, Supplementary material, Section B). Our algorithm APG is simpler than L2S in that it uses only one policy (pre-trained with standard supervised learning) and applies the existing classi\ufb01er directly without reduction (the only requirement is that it is probabilistic). Nevertheless, our results demonstrate its effectiveness. APG belongs to the family of policy gradient algorithms (Sutton et al., 1999), i.e. it maximizes the expected reward directly by following its gradient w.r.t. the parameters. The advantage of using a policy gradient algorithm in NLP is that gradientbased optimization is already widely used. REINFORCE (Williams, 1992; Ranzato et al., 2016) is a widely-used policy gradient algorithm but it is also well-known for suffering from high variance (Sutton et al., 1999). We directly compare our approach to REINFORCE, whereas we leave a direct comparison to L2S for future work. Our experiments show that our algorithm results in lower variance and achieves better performance than REINFORCE. Recent work addresses the approximation of reinforcement learning gradient in the context of machine translation. Shen et al. (2016)\u2019s algorithm is roughly equivalent to the combination of an oracle and random sampling. Their approach differs from ours, because it does not retain memory across iteration as in our best-performing model (see Section 3.4). 2.3 Reinforcement and error propagation As mentioned above, previous work that applied reinforcement learning to NLP has, to our knowledge, not shown that it improved results by reducing error propagation. Work on identifying the impact of error propagation in parsing is rare, Ng and Curran (2015) being a notable exception. They provide a detailed error analysis for parsing and classify which kind of parsing errors are involved with error propagation. There are four main differences between their approaches and ours. First, Ng and Curran correct arcs in the tree and our algorithm corrects decisions of the parsing algorithm. Second, our approach distinguishes between cases where one erroneous action deterministically leads to multiple erroneous arcs and cases where an erroneous action leads to conditions that indirectly result in further errors (see Section 5.1 for a detailed explanation). Third, Ng and Curran\u2019s algorithm corrects all erroneous arcs that are the same type of parsing error and point out that they cannot examine the interaction between multiple errors of the same type in a sentence. Our algorithm corrects errors incrementally and therefore avoids this issue. Finally, the classi\ufb01cation and analysis presented in Ng and Curran (2015) are more extensive and detailed than ours. Our algorithm can, however, easily be extended to perform similar analysis. Overall, Ng and Curran\u2019s approach for error analysis and ours are complementary. Combining them and applying them to various systems would form an interesting direction for future work. 3 A Reinforced Greedy Parser This section describes the systems used in our experiments. We \ufb01rst describe the arc-standard alStep Transition Stack Buffer Arcs 0 <ROOT> waves hit ... Big Board \u2205 1 SHIFT <ROOT> waves hit stocks ... Big Board \u2205 2 SHIFT <ROOT> waves hit stocks themselves ... Big Board \u2205 3 LEFTnsubj <ROOT> hit stocks themselves ... Big Board A1 = { hit nsubj \u2212\u2212\u2212\u2192 waves} 4 SHIFT <ROOT> hit stocks themselves on the Big Board A1 5 SHIFT <ROOT> hit stocks themselves on the Big Board A1 6 RIGHTdep <ROOT> hit stocks on the Big Board A2 = A1\u222a { stock dep \u2212\u2212\u2192 themselves} 7 RIGHTdobj <ROOT> hit on the Big Board A3 = A2\u222a { hit dobj \u2212\u2212\u2212\u2192 stock} Table 1: Parsing oracle walk-through gorithm, because familiarity with it helps to understand our error propagation analysis. Next, we brie\ufb02y point out the main differences between the arc-standard algorithm and the alternative algorithms we experimented with (arc-eager and swapstandard). We then outline the traditional and our novel machine learning approaches. The features we used are identical to those described in Chen and Manning (2014). We are not aware of research identifying the best feature for a neural parser with arc-eager or swap-standard so we use the same features for all transition systems. 3.1 Transition-Based Dependency Parsing In an arc-standard system (Nivre, 2004), a parsing con\ufb01guration consists of a triple \u27e8\u03a3, \u03b2, A\u27e9, where \u03a3 is a stack, \u03b2 is a buffer containing the remaining input tokens and A are the dependency arcs that are created during parsing process. At initiation, the stack contains only the root symbol (\u03a3 = [ROOT]), the buffer contains the tokens of the sentence (\u03b2 = [w1, ..., wn]) and the set of arcs is empty (A = \u2205). The arc-standard system supports three transitions. When \u03c31 is the top element and \u03c32 the second element on the stack, and \u03b21 the \ufb01rst element of the buffer:1 LEFTl adds an arc \u03c31 l\u2212\u2192 \u03c32 to A and removes \u03c32 from the stack. RIGHTl adds an arc \u03c32 l\u2212\u2192 \u03c31 to A and removes \u03c31 from the stack. SHIFT moves \u03b21 to the stack. When the buffer is empty, the stack contains only the root symbol and A contains a parse tree, the con\ufb01guration is completed. For a sentence of 1Naturally, the transitions LEFTl and RIGHTl can only take place if the stack contains at least two elements and SHIFT can only occur when there is at least one element on the buffer. <ROOT> waves hit stocks themselves on the Big Board Figure 1: Correct dependencies for a simpli\ufb01ed example from Penn TreeBank Nw tokens, a full parse takes 2Nw + 1 transitions to complete (including the initiation). Figure 1 provides the gold parse tree for a (simpli\ufb01ed) example from the Penn Treebank. The steps taken to create the dependencies between the sentence\u2019s head word hit and its subject and direct object are provided in Table 1. To demonstrate that reinforcement learning can train different systems, we also carried out experiments with arc-eager (Nivre, 2003) and swapstandard (Nivre, 2009). Arc-eager is designed for incremental parsing and included in the popular MaltParser (Nivre et al., 2006a). Swap-standard is a simple and effective solution to unprojective dependency trees. Because arc-eager does not guarantee complete parse trees, we used a variation that employs an action called UNSHIFT to resume processing of tokens that would otherwise not be attached to a head (Nivre and Fern\u00e1ndezGonz\u00e1lez, 2014). 3.2 Training with a Static Oracle In transition-based dependency parsing, it is common to convert a dependency treebank D \u220b (x, y) into a collection of input features s \u2208 S and corresponding gold-standard actions a \u2208 A for training, using a static oracle O. In Chen and Manning (2014), a neural network works as a function mapping input features to probabilities of actions: fNN : S \u00d7 A \u2192 [0, 1]. The neural network is trained to minimize negative log-likelihood loss on the converted treebank: L = \ufffd (x,y)\u2208D \ufffd (s,a)\u2208O(x,y) \u2212 log fNN(s, a; \u03b8) (1) 3.3 Reinforcement Learning Following Maes et al. (2009), we view transitionbased dependency parsing as a deterministic Markov Decision Process. The problem is summarized by a tuple \u27e8S, A, T , r\u27e9 where S is the set of all possible states, A contains all possible actions, T is a mapping S \u00d7A \u2192 S called transition function and r : S \u00d7 A \u2192 R is a reward function. A state corresponds to a con\ufb01guration and is summarized into input features. Possible actions are de\ufb01ned for each transition system described in Section 3.1. We keep the training approach simple by using only one reward r(\u00afy) at the end of each parse. Given this framework, a stochastic policy guides our parser by mapping each state to a probabilistic distribution of actions. During training, we use function fNN described in Section 3.2 as a stochastic policy. At test time, actions are chosen in a greedy fashion following existing literature. We aim at \ufb01nding the policy that maximizes the expected reward (or, equivalently, minimizes the expected loss) on the training dataset: maximize \u03b7 = \ufffd (x,y)\u2208D \ufffd a1:m\u223cf r(\u00afy) m \ufffd i=1 fNN(si, ai; \u03b8) (2) where a1:m is a sequence of actions obtained by following policy fNN until termination and s1:m are corresponding states (with sm+1 being the termination state). 3.4 Approximate Policy Gradient Gradient ascent can be used to maximize the expected reward in Equation 2. The gradient of expected reward w.r.t. parameters is (note that dz = zd(log z)): \u2202\u03b7 \u2202\u03b8 = \ufffd (x,y)\u2208D \ufffd a1:m\u223cfNN r(\u00afy) m \ufffd i=1 fNN(si, ai) m \ufffd i=1 \u2202 \u2202\u03b8 log fNN(si, ai; \u03b8) (3) Because of the exponential number of possible trajectories, calculating the gradient exactly is not possible. We propose to replace it by an approximation (hence the name Approximate Policy Gradient) by summing over a small subset U of trajectories. Following common practice, we also use a baseline b(y) that only depends on the correct dependency tree. The parameter is then updated by following the approximate gradient: \u2206\u03b8 \u221d \ufffd (x,y)\u2208D \ufffd a1:m\u2208U (r(\u00afy) \u2212 b(y)) m \ufffd i=1 fNN(si, ai) m \ufffd i=1 \u2202 \u2202\u03b8 log fNN(si, ai; \u03b8) (4) Instead of sampling one trajectory at a time as in REINFORCE, Equation 4 has the advantage that sampling over multiple trajectories could lead to more stable training and higher performance. To achieve that goal, the choice of U is critical. We empirically evaluate three strategies: RL-ORACLE: only includes the oracle transition sequence. RL-RANDOM: randomly samples k distinct trajectories at each iteration. Every action is sampled according to fNN, i.e. preferring trajectories for which the current policy assigns higher probability. RL-MEMORY: samples randomly as the previous method but retains k trajectories with highest rewards across iterations in a separate memory. Trajectories are \u201cforgotten\u201d (removed) randomly with probability \u03c1 before each iteration.2 Intuitively, trajectories that are more likely and produce higher rewards are better training examples. It follows from Equation 3 that they also bear bigger weight on the true gradient. This is the rationale behind RL-RANDOM and RL-ORACLE. For a suboptimal parser, however, these objectives sometimes work against each other. RLMEMORY was designed to \ufb01nd the right balance between them. It is furthermore important that the parser is pretrained to ensure good samples. Algorithm 1 illustrates the procedure of training a dependency parser using the proposed algorithms. 2We assign a random number (drawn uniformly from [0, 1]) to each trajectory in memory and remove those assigned a number less than \u03c1. ",
    "Experiments": "Experiments We \ufb01rst train a parser using a supervised learning procedure and then improve its performance using APG. We empirically tested that training a second time with supervised learning has little to no effect on performance. 4.1 Experimental Setup We use PENN Treebank 3 with standard split (training, development and test set) for our experiments with arg-standard and arg-eager. Because the swap-standard parser is mainly suited for nonprojective structures, which are rare in the PENN Treebank, we evaluate this parser on the German ArcArcSwapstandard eager standard UAS LAS UAS LAS UAS LAS SL 91.3 89.4 88.3 85.8 84.3 81.3 RE 91.9 90.2 89.7 87.2 87.5 84.4 RL-O 91.8 90.2 88.9 86.5 86.8 83.9 RL-R 92.2 90.6 89.4 87.0 87.5 84.5 RL-M 92.2 90.6 89.8 87.4 87.6 84.6 Table 2: Comparing training methods on PENN Treebank (arc-standard and arc-eager) and German part of SPMRL-2014 (swap-standard). section of the SPMRL dataset. For PENN Treebank, we follow Chen and Manning\u2019s preprocessing steps. We also use their pretrained model3 for arc-standard and train our own models in similar settings for other transition systems. For reinforcement learning, we use AdaGrad for optimization. We do not use dropout because we observed that it destablized the training process. The reward r(\u00afy) is the number of correct labeled arcs (i.e. LAS multiplied by number of tokens).4 The baseline is \ufb01xed to half the number of tokens (corresponding to a 0.5 LAS score). As training takes a lot of time, we tried only few values of hyperparameters on the development set and picked k = 8 and \u03c1 = 0.01. 1,000 updates were performed (except for REINFORCE which was trained for 8,000 updates) with each training batch contains 512 randomly selected sentences. The Stanford dependency scorer5 was used for evaluation. 4.2 Effectiveness of Reinforcement Learning Table 2 displays the performance of different approaches to training dependency parsers. Although we used Chen and Manning (2014)\u2019s pretrained model and Stanford open-source software, the results of our baseline are slightly worse than what is reported in their paper. This could be due to minor differences in settings and does not affect our conclusions. Across transition systems and two languages, APG outperforms supervised learning, verifying our hypothesis. Moreover, it is not simply because the learners are exposed to more examples than their supervised counterparts. RL-ORACLE 3We use PTB_Stanford_params.txt.gz downloaded from http://nlp.stanford.edu/software/ nndep.shtml on December 30th, 2015. 4Punctuation is not taken into account, following Chen and Manning (2014). 5Downloaded from http://nlp.stanford.edu/ software/lex-parser.shtml. ",
    "Experiment": "Experiment We hypothesized that reinforcement learning avoids error propagation. In this section, we describe our algorithm and the experiment that identi\ufb01es error propagation in the arc-standard parsers. 5.1 Error Propagation Section 3.1 explained that a transition-based parser goes through the sentence incrementally and must select a transition from [SHIFT, LEFTl, <ROOT> waves hit stocks themselves on the Big Board <ROOT> waves hit stocks themselves on the Big Board (A) (B) <ROOT> waves hit stocks themselves on the Big Board (C) Figure 2: Three dependency graphs: gold (A), arc errors caused by one decision error (B) and arc errors caused by multiple decision errors (C). RIGHTl] at each step. We use the term arc error to refer to an erroneous arc in the resulting tree. The term decision error refers to a transition that leads to a loss in parsing accuracy. Decision errors in the parsing process lead to one or more arc errors in the resulting tree. There are two ways in which a single decision error may lead to multiple arc errors. First, the decision can deterministically lead to more than one arc error, because (e.g.) an erroneously formed arc also blocks other correct arcs. Second, an erroneous parse decision changes some of the features that the model uses for future decisions and these changes can lead to further (decision) errors down the road. We illustrate both cases using two incorrect derivations presented in Figure 2. The original gold tree is repeated in (A). The dependency graph in Figure 2 (B) contains three erroneous dependency arcs (indicated by dashed arrows). The \ufb01rst error must have occurred when the parser executed RIGHTamod creating the arc Big \u2192 Board. After this error, it is impossible to create the correct relations on \u2192 Board and Board \u2192 the. The wrong arcs Big \u2192 the and on \u2192 Big are thus all the result of a single decision error. Figure 2 (C) represents the dependency graph that is actually produced by our parser.6 It contains two erroneous arcs: hit \u2192 themselves and themselves \u2192 on. Table 4 provides a possible sequence of steps that led to this derivation, starting from the moment stocks was added to the stack (Step 4). The \ufb01rst error is introduced in Step 5\u2019, where hit combines with stocks before stocks has picked up its dependent themselves. At that point, themselves can no longer be combined with the right head. The proposition on, on the other hand, can 6The example is a fragment of a more complex sentence consisting of 33 tokens. The parser does provide the correct output when is analyzes this sequence in isolation. Step Transition Stack Buffer Arcs 4 SHIFT <ROOT> hit stocks themselves on the Big Board A1 5\u2019 RIGHTdobj <ROOT> hit themselves on the Big Board A2 = A1\u222a {hit dobj \u2212\u2212\u2212\u2192 stock} 6\u2019 SHIFT <ROOT> hit themselves on the Big Board A2 7\u2019 SHIFT <ROOT> hit themselves on the Big Board A2 ... 10\u2019 SHIFT <ROOT> hit themselves on the Big Board A2 11\u2019 LEFTnn <ROOT> hit themselves on the Board A3 = A2\u222a {Board nn \u2212\u2192 Big} 12\u2019 LEFTdet <ROOT> hit themselves on Board A4 = A3\u222a {Board det \u2212\u2212\u2192 the} 13\u2019 RIGHTpobj <ROOT> hit themselves on A5 = A4\u222a {on pobj \u2212\u2212\u2212\u2192 Board} 14\u2019 RIGHTdep <ROOT> hit themselves A6 = A5\u222a {themselves dep \u2212\u2212\u2192on} Table 4: Possible parsing walk-through with error still be combined with the correct head. This error is introduced in Step 7\u2019, where the parser moves on to the stack rather than creating an arc from hit to themselves.7 There are thus two decision errors that lead to the arc errors in Figure 2 (C). The second decision error can, however, be caused indirectly by the \ufb01rst error. If a decision error causes additional decision errors later in the parsing process, we talk of error propagation. This cannot be known just by looking at the derivation. 5.2 Examining the impact of decision errors We examine the impact of individual decision errors on the overall parse results in our test set by combining a dynamic oracle and a recursive function. We use a dynamic oracle based on Goldberg et al. (2014) which gives us the overall loss at any point during the derivation. The loss is equal to the minimal number of arc errors that will have been made once the parse is complete. We can thus deduce how many arc errors are deterministically caused by a given decision error. The propagation of decision errors cannot be determined by simply examining the increase in loss during the parsing process. We use a recursive function to identify whether a particular parse suffered from this. While parsing the sentence, we register which decisions lead to an increase in loss. We then recursively reparse the sentence correcting one additional decision error during each run until the parser produces the gold. If each erroneous decision has to be corrected in order to arrive at the gold, we assume the decision errors are 7Note that technically, on can still become a dependent of hit, but this can only happen if on becomes the head of themselves which would also be an error. SL RL-O RL-R RL-M Total Loss 7069 6227 6042 6144 Dec. Errors 5177 4410 4345 4476 Err. Prop. 1399 1124 992 1035 New errors 411 432 403 400 Loss/error 1.37 1.41 1.39 1.37 Err. Prop. (%) 27.0 25.5 22.8 23.1 Table 5: Overview of average impact of decision errors independent of each other. If, on the other hand, the correction of a speci\ufb01c decision also \ufb01xes other decisions down the road, the original parse suffers from error propagation. The results are presented in Table 5. Total Loss indicates the number of arc errors in the corpus, Dec. Errors the number of decision errors and Err. Prop. the number of decision errors that were the result of error propagation. This number was obtained by comparing the number of decision errors in the original parse to the number of decision errors that needed to be \ufb01xed to obtain the gold parse. If less errors had to be \ufb01xed than originally present, we counted the difference as error propagation. Note that \ufb01xing errors sometimes leads to new decision errors during the derivation. We also counted the cases where more decision errors needed to be \ufb01xed than were originally present and report them in Table 5.8 8We ran an alternative analysis where we counted all cases where \ufb01xing one decision error in the derivation reduced the overall number of decision errors in the parse by more than one. Under this alternative analysis, similar reductions in the proportion of error propagation were observed for reinforcement learning. ",
    "Conclusion": "Conclusion This paper introduced Approximate Policy Gradient (APG), an ef\ufb01cient reinforcement learning algorithm for NLP, and applied it to a highperformance greedy dependency parser. We hypothesized that reinforcement learning would be more robust against error propagation and would hence improve parsing accuracy. To verify our hypothesis, we ran experiments applying APG to three transition systems and two languages. We furthermore introduced an experiment to investigate which portion of errors were the result of error propagation and compared the output of standard supervised machine learning to reinforcement learning. Our results showed that: (a) reinforcement learning indeed improved parsing accuracy and (b) propagated errors were overrepresented in the set of avoided errors, con\ufb01rming our hypothesis. To our knowledge, this paper is the \ufb01rst to show experimentally that reinforcement learning can reduce error propagation in an NLP task. This result was obtained by a straight-forward implementation of reinforcement learning. Furthermore, we only applied reinforcement learning in the training phase, leaving the original ef\ufb01ciency of the model intact. Overall, we see the outcome of our experiments as an important \ufb01rst step in exploring the possibilities of reinforcement learning for tackling error propagation. Recent research on parsing has seen impressive improvement during the last year achieving UAS around 94% (Andor et al., 2016). This improvement is partially due to other approaches that, at least in theory, address error propagation, such as beam search. Both the reinforcement learning algorithm and the error propagation study we developed can be applied to other parsing approaches. There are two (related) main questions to be addressed in future work in the domain of parsing. The \ufb01rst addresses whether our method is complementary to alternative approaches and could also improve the current state-of-the-art. The second question would address the impact of various approaches on error propagation and the kind of errors they manage to avoid (following Ng and Curran (2015)). APG is general enough for other structured prediction problems. We therefore plan to investigate whether we can apply our approach to other NLP tasks such as coreference resolution or semantic role labeling and investigate if it can also reduce error propagation for these tasks. The source code of all experiments is publicly available at https://bitbucket.org/ cltl/redep-java. Acknowledgments The research for this paper was supported by the Netherlands Organisation for Scienti\ufb01c Research (NWO) via the Spinoza-prize Vossen projects (SPI 30-673, 2014-2019) and the VENI project Reading between the lines (VENI 275-89-029). Experiments were carried out on the Dutch national e-infrastructure with the support of SURF Cooperative. We would like to thank our friends and colleagues Piek Vossen, Roser Morante, Tommaso Caselli, Emiel van Miltenburg, and Ngoc Do for many useful comments and discussions. We would like to extend our thanks the anonymous reviewers for their feedback which helped improving this paper. All remaining errors are our own. ",
    "References": "References [Alberti et al.2015] Chris Alberti, David Weiss, Greg Coppola, and Slav Petrov. 2015. Improved Transition-Based Parsing and Tagging with Neural Networks. In EMNLP 2015, pages 1354\u20131359. ACL. [Andor et al.2016] Daniel Andor, Chris Alberti, David Weiss, Aliaksei Severyn, Alessandro Presta, Kuzman Ganchev, Slav Petrov, and Michael Collins. 2016. Globally Normalized Transition-Based Neural Networks. arXiv.org, cs.CL. [Berant and Liang2015] Jonathan Berant and Percy Liang. 2015. Imitation Learning of Agenda-based Semantic Parsers. TACL, 3:545\u2013558. [Bj\u00f6rkelund and Nivre2015] Anders Bj\u00f6rkelund and Joakim Nivre. 2015. Non-Deterministic Oracles for Unrestricted Non-Projective Transition-Based Dependency Parsing. In IWPT 2015, pages 76\u201386. ACL. [Chang et al.2015] Kai-Wei Chang, Akshay Krishnamurthy, Alekh Agarwal, Hal Daum\u00e9 III, and John Langford. 2015. Learning to search better than your teacher. In ICML 2015. [Chen and Manning2014] Danqi Chen and Christopher Manning. 2014. A Fast and Accurate Dependency Parser using Neural Networks. In EMNLP 2014, pages 740\u2013750. ACL. [Daum\u00e9 III et al.2009] Hal Daum\u00e9 III, John Langford, and Daniel Marcu. 2009. Search-based Structured Prediction. Machine Learning, 75(3):297\u2013325, 6. [Dyer et al.2015] Chris Dyer, Miguel Ballesteros, Wang Ling, Austin Matthews, and Noah A Smith. 2015. Transition-Based Dependency Parsing with Stack Long Short-Term Memory. In ACL 2015, pages 334\u2013343. [Gildea and Palmer2002] Daniel Gildea and Martha Palmer. 2002. The Necessity of Parsing for Predicate Argument Recognition. In ACL 2002, pages 239\u2013246. ACL. [Goldberg and Nivre2012] Yoav Goldberg and Joakim Nivre. 2012. A Dynamic Oracle for Arc-Eager Dependency Parsing. In COLING 2012, pages 959\u2013 976. [Goldberg and Nivre2013] Yoav Goldberg and Joakim Nivre. 2013. Training Deterministic Parsers with Non-Deterministic Oracles. In TACL 2013, volume 1, pages 403\u2013414. [Goldberg et al.2014] Yoav Goldberg, Francesco Sartorio, and Giorgio Satta. 2014. A tabular method for dynamic oracles in transition-based parsing. In TACL 2014, volume 2, pages 119\u2013130. [Gomez-Rodriguez et al.2014] Carlos GomezRodriguez, Francesco Sartorio, and Giorgio Satta. 2014. A Polynomial-Time Dynamic Oracle for Non-Projective Dependency Parsing. In EMNLP 2014, pages 917\u2013927. ACL. [Grissom II et al.2014] Alvin C. Grissom II, Jordan Boyd-Graber, He He, John Morgan, and Hal Daume III. 2014. Don\u2019t Until the Final Verb Wait: Reinforcement Learning for Simultaneous Machine Translation. In EMNLP 2014, pages 1342\u20131352. [Han et al.2013] Dan Han, Pascual Mart\u00ednez-G\u00f3mez, Yusuke Miyao, Katsuhito Sudoh, and Masaaki Nagata. 2013. Effects of parsing errors on pre-reordering performance for Chinese-to-Japanese SMT. PACLIC 27, pages 267\u2013276. [Honnibal and Johnson2015] Matthew Honnibal and Mark Johnson. 2015. An Improved Non-monotonic Transition System for Dependency Parsing. In EMNLP 2015, pages 1373\u20131378. ACL. [Jiang et al.2012] Jiarong Jiang, Adam Teichert, Hal Daum\u00e9 III, and Jason Eisner. 2012. Learned Prioritization for Trading Off Accuracy and Speed. ICML workshop on Inferning: Interactions between Inference and Learning, (0964681):1\u20139. [Kiperwasser and Goldberg2016] Eliyahu Kiperwasser and Yoav Goldberg. 2016. Simple and Accurate Dependency Parsing Using Bidirectional LSTM Feature Representations. CoRR, abs/1603.0. [Li et al.2014] Zhenghua Li, Min Zhang, and Wenliang Chen. 2014. Ambiguity-aware Ensemble Training for Semi-supervised Dependency Parsing. In ACL 2014, pages 457\u2013467. [Maes et al.2009] Francis Maes, Ludovic Denoyer, and Patrick Gallinari. 2009. Structured prediction with reinforcement learning. Machine Learning, (77):271\u2013301. [McDonald and Nivre2007] Ryan McDonald and Joakim Nivre. 2007. Characterizing the Errors of Data-Driven Dependency Parsing Models. In EMNLP-CoNLL 2007. [McDonald et al.2005] Ryan McDonald, Fernando Pereira, Kiril Ribarov, and Jan Haji\u02c7c. 2005. Nonprojective dependency parsing using spanning tree algorithms. In HLT-EMNLP 2005, pages 523\u2013530. Association for Computational Linguistics. [Ng and Curran2015] Dominick Ng and James R Curran. 2015. Identifying Cascading Errors using Constraints in Dependency Parsing. In ACL-IJCNLP, pages 1148\u20131158, Beijing. ACL. [Nivre and Fern\u00e1ndez-Gonz\u00e1lez2014] Joakim Nivre and Daniel Fern\u00e1ndez-Gonz\u00e1lez. 2014. Arc-eager Parsing with the Tree Constraint. Computational Linguistics, 40(2):259\u2013267, 6. [Nivre et al.2006a] Joakim Nivre, Johan Hall, and Jens Nilsson. 2006a. MaltParser: A data-driven parsergenerator for dependency parsing. In LREC 2006, volume 6, pages 2216\u20132219. [Nivre et al.2006b] Joakim Nivre, Johan Hall, Jens Nilsson, G\u00fcl\u00b8sen Eryi\u02d8git, and Svetoslav Marinov. 2006b. Labeled pseudo-projective dependency parsing with support vector machines. In CoNLL 2006, pages 221\u2013225. ACL. [Nivre et al.2007] Joakim Nivre, Johan Hall, Jens Nilsson, Atanas Chanev, Eryi\u02c7git G\u00fcl\u00b8sen, Sandra K\u00fcbler, Svetoslav Marinov, and Erwin Marsi. 2007. MaltParser: A language-independent system for datadriven dependency parsing. Natural Language Engineering, 13(02):95\u2013135. [Nivre2003] Joakim Nivre. 2003. An Ef\ufb01cient Algorithm for Projective Dependency Parsing. In IWPT 2003, pages 149\u2013160. [Nivre2004] Joakim Nivre. 2004. Incrementality in Deterministic Dependency Parsing. In Proceedings of the Workshop on Incremental Parsing: Bringing Engineering and Cognition Together. [Nivre2009] Joakim Nivre. 2009. Non-projective Dependency Parsing in Expected Linear Time. In ACLIJCNLP 2009, pages 351\u2013359, Stroudsburg, PA, USA. ACL. [Quirk and Corston-Oliver2006] Chris Quirk and Simon Corston-Oliver. 2006. The impact of parse quality on syntactically-informed statistical machine translation. In EMNLP 2006, pages 62\u201369, Sydney, Australia. ACL. [Ranzato et al.2016] Marc\u2019Aurelio Ranzato, Sumit Chopra, Michael Auli, and Wojciech Zaremba. 2016. Sequence Level Training with Recurrent Neural Networks. ICLR, pages 1\u201315. [Ross et al.2011] Stephane Ross, Geoffrey J Gordon, and J Andrew Bagnell. 2011. A Reduction of Imitation Learning and Structured Prediction to NoRegret Online Learning. AISTATS, 15:627\u2013635. [Seddah et al.2014] Djam\u00e9 Seddah, Sandra K\u00fcbler, and Reut Tsarfaty. 2014. Introducing the SPMRL 2014 Shared Task on Parsing Morphologically-Rich Languages. In Proceedings of the First Joint Workshop on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical Languages, pages 103\u2013109. [Shen et al.2016] Shiqi Shen, Yong Cheng, Zhongjun He, Wei He, Hua Wu, Maosong Sun, and Yang Liu. 2016. Minimum Risk Training for Neural Machine Translation. In ACL 2016, pages 1683\u20131692, Berlin, Germany. ACL. [Song et al.2012] Hyun-Je Song, Jeong-Woo Son, TaeGil Noh, Seong-Bae Park, and Sang-Jo Lee. 2012. A Cost Sensitive Part-of-Speech Tagging: Differentiating Serious Errors from Minor Errors. In ACL 2012, pages 1025\u20131034. ACL. [Sutton et al.1999] Richard S. Sutton, David Mcallester, Satinder Singh, and Yishay Mansour. 1999. Policy Gradient Methods for Reinforcement Learning with Function Approximation. In NIPS 1999, pages 1057\u20131063. [Weiss et al.2015] David Weiss, Chris Alberti, Michael Collins, and Slav Petrov. 2015. Structured Training for Neural Network Transition-Based Parsing. In ACL-IJCNLP 2015, pages 323\u2013333. ACL. [Williams1992] Ronald J. Williams. 1992. Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning, 8(3-4):229\u2013256. [Yamada and Matsumoto2003] Hiroyasu Yamada and Yuji Matsumoto. 2003. Statistical Dependency Analysis with Support Vector Machines. In Proceedings of IWPT, pages 195\u2013206. [Yang and Cardie2013] Bishan Yang and Claire Cardie. 2013. Joint Inference for Fine-grained Opinion Extraction. In ACL 2013, pages 1640\u20131649. ACL. [Zhang and Chan2009] Lidan Zhang and Kwok Ping Chan. 2009. Dependency Parsing with Energybased Reinforcement Learning. In IWPT 2009, pages 234\u2013237. ACL. ",
    "title": "Tackling Error Propagation through Reinforcement Learning:",
    "paper_info": "Tackling Error Propagation through Reinforcement Learning:\nA Case of Greedy Dependency Parsing\nMinh L\u00ea\nCLTL\nVrije Universiteit Amsterdam\nAmsterdam, The Netherlands\nm.n.le@vu.nl\nAntske Fokkens\nCLTL\nVrije Universiteit Amsterdam\nAmsterdam, The Netherlands\nantske.fokkens@vu.nl\nAbstract\nError propagation is a common problem\nin NLP. Reinforcement learning explores\nerroneous states during training and can\ntherefore be more robust when mistakes\nare made early in a process. In this paper,\nwe apply reinforcement learning to greedy\ndependency parsing which is known to\nsuffer from error propagation. Reinforce-\nment learning improves accuracy of both\nlabeled and unlabeled dependencies of\nthe Stanford Neural Dependency Parser,\na high performance greedy parser, while\nmaintaining its ef\ufb01ciency. We investigate\nthe portion of errors which are the result\nof error propagation and con\ufb01rm that rein-\nforcement learning reduces the occurrence\nof error propagation.\n1\nIntroduction\nError propagation is a common problem for many\nNLP tasks (Song et al., 2012; Quirk and Corston-\nOliver, 2006; Han et al., 2013; Gildea and Palmer,\n2002; Yang and Cardie, 2013). It can occur when\nNLP tools applied early on in a pipeline make\nmistakes that have negative impact on higher-level\ntasks further down the pipeline. It can also occur\nwithin the application of a speci\ufb01c task, when se-\nquential decisions are taken and errors made early\nin the process affect decisions made later on.\nWhen reinforcement learning is applied, a sys-\ntem actively tries out different sequences of ac-\ntions. Most of these sequences will contain some\nerrors. We hypothesize that a system trained in this\nmanner will be more robust and less susceptible to\nerror propagation.\nWe test our hypothesis by applying reinforce-\nment learning to greedy transition-based parsers\n(Yamada and Matsumoto, 2003; Nivre, 2004),\nwhich have been popular because of superior ef\ufb01-\nciency and accuracy nearing state-of-the-art. They\nare also known to suffer from error propagation.\nBecause they work by carrying out a sequence of\nactions without reconsideration, an erroneous ac-\ntion can exert a negative effect on all subsequent\ndecisions. By rendering correct parses unreach-\nable or promoting incorrect features, the \ufb01rst error\ninduces the second error and so on. McDonald\nand Nivre (2007) argue that the observed negative\ncorrelation between parsing accuracy and sentence\nlength indicates error propagation is at work.\nWe compare reinforcement learning to super-\nvised learning on Chen and Manning (2014)\u2019s\nparser. This high performance parser is available\nas open source. It does not make use of alterna-\ntive strategies for tackling error propagation and\nthus provides a clean experimental setup to test\nour hypothesis. Reinforcement learning increased\nboth unlabeled and labeled accuracy on the Penn\nTreeBank and German part of SPMRL (Seddah\net al., 2014). This outcome shows that reinforce-\nment learning has a positive effect, but does not yet\nprove that this is indeed the result of reduced er-\nror propagation. We therefore designed an exper-\niment which identi\ufb01ed which errors are the result\nof error propagation. We found that around 50%\nof avoided errors were cases of error propagation\nin our best arc-standard system. Considering that\n27% of the original errors were caused by error\npropagation, this result con\ufb01rms our hypothesis.\nThis paper provides the following contributions:\n1. We introduce Approximate Policy Gradient\n(APG), a new algorithm that is suited for de-\npendency parsing and other structured pre-\ndiction problems.\n2. We show that this algorithm improves the ac-\ncuracy of a high-performance greedy parser.\narXiv:1702.06794v1  [cs.CL]  22 Feb 2017\n",
    "GPTsummary": "- (1): The research background of this article is mainly about the negative impact of error propagation, which is a common problem in many natural language processing tasks. \n\n- (2): Previous methods have not been effective in handling error propagation, and this article uses reinforcement learning with a focus on its ability to explore erroneous states during training and reduce the occurrence of error propagation. The approach is well motivated by the observation that greedy transition-based parsers, which are popular due to their efficiency and accuracy, are especially prone to error propagation. \n\n- (3): The research methodology proposed in this paper is to apply approximate policy gradient, a new algorithm suited for dependency parsing and structured prediction problems, to greedy dependency parsing as a means of reducing error propagation. \n\n- (4): The methods in this paper are evaluated on the Penn TreeBank and German part of SPMRL datasets using the Stanford Neural Dependency Parser, and they show that reinforcement learning improves accuracy in both labeled and unlabeled dependencies while maintaining efficiency. The results suggest that reinforcement learning is effective in reducing the occurrence of error propagation and improving parsing accuracy.\n\n\n\n\n\n8. Conclusion: \n\n- (1): The significance of this work is the introduction of the Approximate Policy Gradient (APG), a reinforcement learning algorithm for natural language processing (NLP). The study shows the effectiveness of APG in reducing error propagation and improving parsing accuracy in dependency parsing, which is a common NLP task.\n\n- (2): Innovation point: The innovation of this article comes from the use of reinforcement learning, which has the ability to explore erroneous states during training and reduce error propagation. Performance: The study shows that reinforcement learning improves parsing accuracy in both labeled and unlabeled dependencies while maintaining efficiency. Workload: The workload of implementing the APG algorithm is moderate, and the code is publicly available for other researchers to use. However, further research is needed to investigate whether this approach is complementary to other methods and to apply it to other NLP tasks.\n\n\n",
    "GPTmethods": " not found",
    "GPTconclusion": "- (1): The significance of this work is the introduction of the Approximate Policy Gradient (APG), a reinforcement learning algorithm for natural language processing (NLP). The study shows the effectiveness of APG in reducing error propagation and improving parsing accuracy in dependency parsing, which is a common NLP task.\n\n- (2): Innovation point: The innovation of this article comes from the use of reinforcement learning, which has the ability to explore erroneous states during training and reduce error propagation. Performance: The study shows that reinforcement learning improves parsing accuracy in both labeled and unlabeled dependencies while maintaining efficiency. Workload: The workload of implementing the APG algorithm is moderate, and the code is publicly available for other researchers to use. However, further research is needed to investigate whether this approach is complementary to other methods and to apply it to other NLP tasks.\n\n\n"
}